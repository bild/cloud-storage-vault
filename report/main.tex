\documentclass[pdftex,english,10pt,b5paper,twoside]{book}
%TODO: Correct format, not a4
\usepackage[T1]{fontenc} % In case we want special characters
\usepackage[utf8]{inputenc} % We are all writing in UTF-8

\usepackage[numbers]{natbib} % We need to tweak our referencing a bit.
\usepackage{appendix} % Fixes formatting of appendices
\usepackage[printonlyused]{acronym} % Package to handle the acronym list
\usepackage{graphicx} % We *may* use images
\graphicspath{{images/}} % and it is clean to put them in a separate dir
\usepackage{hyperref} % Internal and external links is nice
\hypersetup{pdfborder=0 0 0} % ..especially without red borders
\usepackage{amstext} % To support \text in math mode

% Packages and settings for code listings
\usepackage{listings}
\usepackage{caption}
\usepackage{upquote}
\usepackage{xcolor}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{
language=Java,
keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
identifierstyle=\ttfamily,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
showstringspaces=false,
basicstyle=\small,
numberstyle=\footnotesize,
numbers=left,
stepnumber=1,
numbersep=10pt,
tabsize=2,
breaklines=true,
prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
breakatwhitespace=false,
aboveskip={1.5\baselineskip},
columns=fixed,
upquote=true,
extendedchars=true,
frame=bottomline,
inputencoding=utf8
}

% Set equal margins on book style
% \usepackage{layout} % Use \layout to print out the margins (debug)
%\usepackage{geometry}
%\geometry{bindingoffset=1cm}
\usepackage[lmargin=25mm,rmargin=25mm,tmargin=27mm,bmargin=30mm]{geometry}

% Restyle chapter headers
\usepackage{fix-cm}
\makeatletter
\renewcommand{\@makechapterhead}[1]{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \vspace{15pt}%
    \ifnum \c@secnumdepth >\m@ne
        %\hfill\huge\scshape \@chapapp\space
        \hfill\fontsize{60}{90}\selectfont \thechapter % Chapter number
        \par\nobreak
        \vskip 20\p@
    \fi
    \interlinepenalty\@M
    \hfill \Huge \scshape #1\par % Chapter title
    \vspace{5pt}
    \hrule
    \nobreak
    \vskip 40\p@
  }}
\makeatother

\author{Eirik Haver \and Eivind Melvold \and Pål Ruud}
\title{Master thesis - Cloud Storage Vault}
\date{\today}

\begin{document}

\include{title}
\pagestyle{empty}

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
\pagestyle{plain}
\pagenumbering{Roman}
\setcounter{page}{1}

%  Writers should follow a checklist consisting of:
% Motivation: Why do we care about the problem and results?
% Problem Statement: What problem are we trying to solve? Scope/limits.
% Approach: How did we go about solving or making progress on the problem?
% Results: What is the answer? Numbers, not vague 'very', 'small' etc.
% Conclusions: What are the implications of your answer? Further work.
%
%  Each section is typically a single sentence, although there is room for
%  creativity.

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

The work behind this project report was carried out during the spring semester
in 2011 at the Norwegian University of Science and Technology (NTNU), Department
of Telematics (ITEM).
\vspace{13pt}

\begin{center}
Eirik Haver, Eivind Melvold and Pål Ruud
\vspace{13pt}

\end{center}

\tableofcontents

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\listtablename}
\listoftables

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\lstlistlistingname}
\lstlistoflistings
\cleardoublepage

\chapter*{Acronyms}
\addcontentsline{toc}{chapter}{Acronyms}

\begin{acronym}
\acro{ACL}{Access Control List}
\acro{AES}{Advanced Encryption Standard}
\acro{CA}{Certification authority}
\acro{CBC}{Cipher Block Chaining}
\acro{CM}{Cloud Manager}
\acro{DRY}{Don't Repeat Yourself}
\acro{DSA}{Digital Signature Algorithm}
\acro{DSS}{Digital Signature Scheme}
\acro{ECB}{Electronic Codeboo}
\acro{ETE}{External Trusted Entity}
\acro{FAQ}{Frequently Asked Questions}
\acro{HTTP}{Hypertext Transfer Protocol}
\acro{IaaS}{Infrastructure as a Service}
\acro{IV}{Initialization Vector}
\acro{JCA}{Java Cryptography Architecture}
\acro{JCE}{Java Cryptographic Extensions}
\acro{JDK}{Java Development Kit}
\acro{JRE}{Java Runtime Environment}
\acro{LAFS}{Least Authority File System}
\acro{MITM}{Man-in-the-middle}
\acro{NIST}{National Institute of Standards and Technology}
\acro{PBKDF2}{Password-Based Key Derivation Function version 2}
\acro{PaaS}{Platform as a Service}
\acro{PasS}{Privacy as a Service}
\acro{PEP}{Python Enhancement Proposal}
\acro{PGP}{Pretty Good Privacy}
\acro{PKI}{Public Key Infrastructure}
\acro{REST}{Representational State Transfer}
\acro{RSA}{Rivest, Shamir and Adleman}
\acro{SaaS}{Software as a Service}
\acro{SHA}{Secure Hash Algorithm}
\acro{SSL}{Secure Socket Layer}
\acro{TC}{Trusted Coordinator}
\acro{TCCP}{Trusted Cloud Computing Platform}
\acro{TCG}{Trusted Computing Group}
\acro{TLS}{Transport Layer Security}
\acro{TPM}{Trusted Platform Module}
\acro{TTP}{Trusted Third Party}
\acro{TVMM}{Trusted Virtual Machine Monitor}
\acro{URL}{Uniform Resource Locator}
\acro{VM}{Virtual Machine}
\acro{VMM}{Virtual Machine Monitor}
\acro{WSGI}{Web Server Gateway Interface}
\end{acronym}

%**************************************%
\chapter{Introduction}
%**************************************%
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Method}

\section{Outline}

The work is presented as per the following chapters:

\paragraph{Chapter 2} provides background knowledge of the technologies and
software used.


%**************************************%
\chapter{Background}
%**************************************%

\section{Security Services}

This section explains certain security services used in this thesis. A security
service is any processing or communication service that enhances the security of
the data processing systems and the information transfers of any organization
\cite[p. 12]{stallings}.

\paragraph{Confidentiality} is the art of keeping a message secret from
unauthorized parties \cite[p. 18]{stallings}. This can typically be done by
either preventing other parties access to the message at all, or making the
contents unreadable, for instance by the use of encryption.

\paragraph{Integrity} in a security perspective deals with detecting,
preventing or recovering a message being changed by an unauthorized party
\cite{stallings}.

\paragraph{Authentication} is the act for a user, service or similar to prove
that he is what he claims to be \cite{stallings}.

\paragraph{Nonrepudiation} prevents both sender and receiver of a message
from denying a transmitted message, in other words one party can prove the
other parties involvement \cite{stallings}.

\section{Cryptographic Primitives}

This section explains the low level security primitives used in this thesis.

\subsection{Encryption}

Encryption is the process of transforming some
information into an unreadable form. Encryption is primarily used to enforce
Confidentially, but can also be used for other purposes such as authentication.
In a very basic form an encryption scheme consist of an encryption algorithm,
the \emph{cipher}, a key and a message, the \emph{plaintext}, that is all used
to create an encrypted message, the \emph{ciphertext}. If a good cipher is
used, knowledge of the cipher, plaintext and ciphertext should not be enough to
obtain the key.
% TODO: Kilde: schneier?

\paragraph{Block-cipher and Stream-cipher} are classifications on how a cipher
treats data\cite[p. 32]{stallings}. A block cipher will encrypt a block of data
of a specific size. If the data is larger than the block size used by the
application a \emph{mode of operation} is needed. In a stream cipher the
plaintext will usually be combined with a pseudorandom key stream to generate
the plaintext.

\paragraph{Symmetric encryption} is an encryption scheme where the same key is
used for both encryption and decryption\cite[p. 32]{stallings}. \ac{AES} is a
block cipher and is the current standard for symmetric encryption. \ac{AES}
works on a block of 128-bit and support keys of 128, 192 and 256-bit.

\paragraph{The mode of operation} used for a symmetric encryption enables
subsequent safe use of the same key. In a simple scenario this could be to
encrypt the normal data block-by-block with pure \ac{AES}, which is called the
\ac{ECB} mode of operation. The problem with this is that some information of
the ciphertext will leak, i.e. the same plaintext will always be the same
ciphertext. A more usefull way is \emph{\ac{CBC}}. In \ac{CBC} you will need an
\ac{IV} which should be non-predictable, and not reused. The \ac{IV} is XORed
with the first block of plaintext, which again is encrypted with \ac{AES}. The
resulting ciphertext is used as an \ac{IV} for the next block.
%TODO: kilde: scheiner?

\paragraph{Asymmetric encryption} is an encryption scheme where a different key
is used for encryption than decryption\cite[p. 259]{stallings}. An asymmetric
encryption scheme is often called a public-key encryption scheme, where one key
is defined as private and the other as public. The public key is shared to
allow other parties to encrypt messages for the owner of the private key. The
downside of asymmetric encryption compared to symmetric is that it requires a
larger key and has a larger computational overhead to obtain the same level of
confidentiality. The probably best known asymmetric cipher is \ac{RSA}.

\subsection{Cryptographic hash functions}
A cryptographic hash function is a deterministic mathematical procedure which
takes an arbitrary block of data and outputs a fixed-size bit string. The output
is referred to as the hash value, message digest or simply digest.
Another property of a cryptographic hash function is that the smallest change in
the input data (e.g. one bit) should completely change the output of the hash
function. In other words it should be infeasible to find the reverse of a
cryptographic hash function \cite[p. 335]{stallings}. It should also be infeasible to
find two blocks of data which produce the same hash value (a \emph{collision}).

The standard for cryptographic hash functions today are \ac{SHA}-1 and the
\ac{SHA}-2 family.

\section{Applications of cryptographic primitives}

\subsection{Digital Signatures}
A digital signature is the digital equivalent of a normal signature, it
verifies that an entity approves with or has written a message, the date the
signature was made and it should be verifiable by a third party \cite[p.
379]{stallings}. It should logically not be possible or at least unfeasible to
fake a digital signature. It is possible to create digital signatures with
\ac{RSA} there is also a standard for digital signatures called \ac{DSS} which
uses \ac{DSA} as the actual algorithm.

\subsection{Digital Certificates and PKI} A digital certificate is the pairing
of a digital signature and a public key\cite{stallings}.  By this scheme the
services confidentiality, authentication and nonrepudiation can be achieved.
Basically a person or other entity has a certificate with some clues about the
identity in it, e.g. the e-mail, together with a public key. This certificate
can then be signed using digital signatures to verify that some other entity
trusts this certificate. In practise the entity which signs certificates is the
\ac{CA} which all clients have the public key information for, and trusts. The
\ac{CA} will also contain information about which certificates has been
revoked, i.e. should not be trusted in use. Such a scheme is usually referred
to as a \ac{PKI}.

\subsubsection{PGP} \ac{PGP} is a scheme similar to \ac{PKI} but with no
\ac{CA} that all users trusts\cite{stallings}. Instead trust is made between
users by somehow verifying their public key, for instance by meeting face to
face. A user can then sign another users key, set a trust level for the user
and publish this information to a keyserver. Another user can then calculate a
trust to an unknown person based on the trust set by peoples that he trusts.

\subsection{SSL/TLS}
\ac{TLS} and its predecessor \ac{SSL} are techniques for obtaining
confidentiality, integrity for transfer of files over a
network\cite{stallings}. It does so by a combination of different algorithms
and primitives, but a digital certificate is required for authentication.

\subsection{PBKDF2}
%TODO: See if we actually use this.
\ac{PBKDF2} is a key derivation function to create an encryption key based on
a password. The point of this is that a password is often something that should
be memorable to a person, but what is memorable to a person might be a to short
phrase to withstand a brute force attack. What \ac{PBKDF2} does is make the
process of deriving the key from the password an expensive process in terms of
computational power, to make it more resistant to brute force attacks.

\section{Security Attacks}
This section briefly list security attacks relevant to this thesis, as defined
by \citeauthor{stallings}.
%TODO: Mulig man skal bruke en annen måte å refere kilden på her

\paragraph{Active and passive attacks} are classifications of security attacks,
where a passive attack attempts to learn or make use of information from the
system but does not affect system resources. An active attack attempts to alter
system resources or affect their operation.

\paragraph{Traffic analysis} is the art of capturing communication sent between
two parties. This information might contain secrets or might for instance leak
enough information about an encryption key to make it breakable.

\paragraph{Masquerade} is an active attack where the attacker pretends to be
one of the legit parties.

\paragraph{Replay} is an active attack where the attacker capture some data in
a communication session and subsequently retransmit that information.

\paragraph{Modification of messages} is an active attack where the attacker
alters some of the contents of a message sent between two communicating
parties.

\paragraph{Denial of Service} is an active attack where the attacker seeks to
make resources unavailable for legit users, i.e. by overloading an application
by sending it lots of traffic.

\paragraph{\acl{MITM}} is an attack where an attacker intercepts messages
between the communicating parties and then either relay or substitute the
intercepted message.

\subsection{Attacks on cryptographic primitives}
Even though cryptographic primitives are designed to be secure, they might have
both flaws and be used in an incorrect fashion.

\paragraph{Cryptanalysis attack} is an attempt to deduce a specific plaintext
or to deduce the key being used in a ciphertext.

\paragraph{Brute-force attack} is an attack where you try to obtain a secret by
testing the algorithm with up to all possible inputs. The secret might be an
encryption key or the data fed into a cryptographic hash function.

\section{Cloud Computing}
In a draft\cite{cloud_nistdef} \ac{NIST} defines cloud computing as:
\begin{quote}
Cloud computing is a model for enabling ubiquitous, convenient,
on-demand network access to a shared pool of configurable computing resources
(e.g., networks, servers, storage, applications, and services) that can be
rapidly provisioned and released with minimal management effort or service
provider interaction.
\end{quote}

\subsection{Service Models}
\ac{NIST} also defines three service models which deals with what kind of
service the consumer is able to rent from a provider.

\paragraph{\ac{SaaS}} is the capability for a consumer to run the provider's
application running on cloud infrastructure, using a thin-client, browser or
similar. Gmail\footnote{\url{http://www.gmail.com}} can be seen as an example
of this.

\paragraph{\ac{PaaS}} is the capability for a consumer to deploy software onto
the cloud, but without actually controlling the underlying platform, operating
system etc.

\paragraph{\ac{IaaS}} is the capability provided to the consumer to provision
processing, storage, networks and other fundamental computing resources where
he can run arbitrary software, including operating systems and applications. An
example is hiring a \ac{VM}.

\subsection{Deployment Models}
The \ac{NIST} draft also lists several Deployment Models which deals with how
the cloud is organized in terms of where it is hosted and who has access to it.

\paragraph{Private Cloud} is a cloud infrastructure operated solely for an
organization. Which party manages the cloud and where it is located is not
given.

\paragraph{Community Cloud} is a cloud infrastructure is shared by several
organizations to serve a common concern. Where it is located and who manages it
is not given.

\paragraph{Public Cloud} is a cloud infrastructure where basically everyone or
at least a large group can have access, and is owned by a external provider of
cloud services.

\paragraph{Hybrid Cloud} is a cloud infrastructure composed of two or more
clouds of any other model.

\subsection{Security considerations}
There are some considerations when using cloud services from an external provider
as opposed to self controlled hardware, software and plattforms. Most notably
is that you loose the control of selecting the people which will have physical
and digital access to the infrastructure. In essence this means that the
provider can read every data sent to and from the cloud as well as the data
saved in the cloud.

Another risk is that information might be leaked to other users of the same
cloud. For instance it might be able possible for a \ac{VM} to leak information
to other \ac{VM}s on the same host.
%TODO: kilde

%**************************************%
\chapter{Related Work}
%**************************************%

\section{Research}
This section will elaborate on previous research concerning privacy within cloud
computing. Previous research can be divided into proactive solutions that
either reduce or prevent the risk of leaking privacy related information. The
latter type of solutions are discussed.

\subsection{Privacy as a Service}
A concept entitled \ac{PasS} was suggested in 2009
\cite{PasS}. PasS is a set of security protocols ensuring privacy of customer
data in cloud computing architectures. The main design goal with PasS is to
maximize the user's control over his/her sensitive data both processed and stored
within a cloud.

To be operational, PasS is dependent on a fundamental system and trust model. The
system model consists of 3 communicating parties, namely a cloud provider, a
cloud customer and a \ac{TTP}. The PasS system model is shown
in Figure \ref{fig:RW:PasS}. 

It is important to notice that the PasS system model is dependent on
pre-installed cryptographic coprocessors in the cloud. A cryptographic
coprocessor is a small hardware card, including a processor, RAM, ROM, backup
battery, persistent storage and an Ethernet network card. A coprocessor interfaces
with a server in the cloud and provides a safe environment for processing of
a customer's sensitive/private data. The cryptographic coprocessors are used in the
cloud because they are tamper-proof against physical attacks. The coprocessors
are pre-configured by the TTP before they are installed in the cloud. In this
way, the TTP provides a safe computational environment for the cloud customer,
which is kept secret from the cloud provider.

The main task of the TTP is to compute a set of public/private key pairs, load
them into the co-processor's persistent storage in the cloud, and
further send them to the customer. The TTP also loads its own secret key into
the coprocessor. This key distribution ensures secure communication between the
TTP, coprocessors and the cloud customer. The customer's key pair is sent through a
secure communication channel.

With cryptographic coprocessors in the cloud and a secure communication, the
cloud customer can choose between 3 different levels of privacy towards the
cloud provider. The customer can choose between no privacy, privacy with trusted
provider and privacy with none-trusted provider.

No privacy equals storing data as clear text in the cloud. Privacy with trusted
provider involves storing encrypted data in the cloud. This data is encrypted by
the cloud provider and only achievable by the customer or cloud provider.
In the case of privacy with non-trusted provider, the customer encrypts the
private data before uploading it to the cloud provider. The key used for
encryption is shared with the cryptographic co-processor, through an
authenticated version of the Diffie-Hellman key management protocol. The
co-processor can further process the encrypted data and store it in the cloud
facility. The stored data is encrypted and unknown to the cloud provider.

\subsection{Privacy Manager}
\
In 2009, HP Labs proposed a way to manage and control a user's private data stored and
processed in a cloud facility \cite{privacymanager}. Their solution was partially implemented
as a software program called a privacy manager.

The privacy manager uses a feature/method called obfuscation, which is quiet similar to
encryption. However, the obfuscation method is different from encryption, in the
sense that the obfuscated data can be processed in the cloud, without the cloud
provider knowing the encryption key or the original data. \cite{privacymanager} mention the following
obfuscation methods:
\begin{itemize}
\item Yao's protocol for secure two-party computation \cite{yao}
\item Gentry's homomorphic encryption scheme \cite{gentry}
\item Narayanan and Schmatikov's obfuscation method \cite{obfuscationmethod}
\end{itemize}
Due to better efficiency, the privacy manager uses the latter alternative. However,
Narayanan and Schmatikov's obfuscation method does not provide complete
confidentiality to the cloud provider \cite{obfuscationmethod}.

In addition to installing a privacy manager at the user's terminal, HP Labs suggests
the use of trusted computing solutions to address the lower-level protection of
data. The \ac{TCG} is an example of an organization
developing and providing trusted computing solutions \cite{tcg}. HP Labs
suggests using a tamper-proof piece of hardware called a \ac{TPM}, which is
designed by TCG. The TPM is installed in the machine running the
privacy manager to ensure that processes carried out by the privacy manager can be
fully trusted.

The privacy manager is suggested to work in 3 different use cases. It can be
implemented to support a single client, the use of hybrid clouds and/or the use of an
infomediary within the cloud.

%Regarding applications in the cloud where users have to upload unobfuscated
%private data, the privacy manager includes two additional features called
%preferences and personae. Both features are dependent on a trustworthy service
%and cloud provider, and are therefore irrelevant to our development.

\subsection{Trusted Cloud Computing Platform}
Equal to PasS and the privacy manager, \ac{TCCP} was proposed as a solution to
provide secure computations (and storage) within a non-trusted cloud provider
\cite{tccp}. As opposed to the previous solutions, TCCP is directed against secure
execution of guest VMs outsourced to IaaS providers. 

The original IaaS structure, before adding TCCP, is assumed to consist of a
\ac{CM}, which manages a cluster of nodes running one or more VMs. Among
multiple tasks, the CM is responsible for loading VM images into its own nodes.
Each node has a \ac{VMM} which will further launch and monitor VMs from the
received VM images.

TCCP is based upon the fundamental TPM chip designed by the TCG. The TPM
contains a private/public key pair that uniquely identifies the TPM. The public
key is additionally signed by the manufacturer to guarantee correctness of
the TPM chip. With this in mind, TCCP is based upon a remote attestation scheme.
The remote attestation scheme enables a network entity to verify whether another
remote entity runs a TPM or not. A detailed description of the remote
attestation scheme is given in \cite{tccp}.

The TCCP system architecture is illustrated in Figure \ref{fig:RW:TCCP}. The
trusted computing base of TCCP includes a \ac{TC} and a \ac{TVMM}. The TC
manages the trusted nodes within a cluster. To be trusted, a node must be
located within a security perimeter and run a TVMM. The TC maintains a record of
the nodes located in the security perimeter and use remote attestation to ensure
nodes are trusted. Each trusted node in a cluster contains a TPM and a
corresponding TVMM. The main task of a TVMM is to enforce a local closed box
protection of a client's running VM. Details about the TVMM design are given in
\cite{tvmm}. 

Each TVMM cooperates with a TC to protect the transmission of VMs between
trusted nodes and to ensure that VMs are executed by trusted nodes. In this
context, the TCCP specifies several protocols for both launching and migrating
VMs inside the cloud. These protocols are described in \cite{tccp}.

The TC is installed in an \ac{ETE}, maintained by a trusted third party, to prevent illegal tampering
from the IaaS provider. A client can further use remote attestation to the TC to
verify that the IaaS provider secures its computation.

With TCCP the client interacts with the IaaS provider as usual. The difference
is that the trusted nodes and their TC communicates to ensure a secure environment for executing
the client's VM.

\subsection{Cryptographic Cloud Storage}

\section{Existing Solutions}
There are a number of existing storage solutions for storing data in the cloud,
with more or less of the functionality required to fulfill the problem
description for this thesis. The section highlights some of them.

\subsection{Dropbox} Dropbox\footnote{\url{http://www.dropbox.com}} is a
commercial application for storing data in the cloud, more specific using
Amazons S3 storage service. It claims that files are stored encrypted with
\ac{AES}-256 which can only be decrypted with the users username and password,
and that Dropbox employees are not able to access the files of the
user\footnote{\url{http://www.dropbox.com/help/27}}. However Dropbox also has a
Forgot password feature which means that Dropbox can read the users files if
they really want to. Their \ac{FAQ} does however say that some people have been
successfull in putting truecrypt containers in Dropbox which efficiently makes
Dropbox secure\footnote{\url{http://www.dropbox.com/help/179}}.

\subsection{Tahoe-LAFS}
Tahoe-\ac{LAFS}\footnote{http://www.tahoe-lafs.org} is an open source
cloud storage file system which does fulfill the requirements set by our
problem description in regards to security. In Tahoe-\ac{LAFS} files are
exclusivly encrypted client-side, before beeing uploaded into the cloud.
Tahoe-\ac{LAFS} also uses erasure-coding to obtain redundancy across multiple
storage servers.

%TODO: kilde, enten paperet vi brukte i prosjektet, muligens
% http://tahoe-lafs.org/source/tahoe-lafs/trunk/docs/about.html

%**************************************%
\chapter{Architectural Overview}
%**************************************%
\label{chap:AS}

The architectural solution of a secure cloud file sharing system has to convince
its users that the functions indeed are secure, and that the concepts are easy
to understand and accept.

\section{Introduction}
% FIXME: Can we just drop this section and include its contents in the chapter
% intro?

The architecture has to support various user functionality. Figure
\ref{fig:AS:overview} exhibits Alice uploading files to the cloud, and
thereafter transferring the necessary information to Bob so that he also can
gain access to the files.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureOverview.pdf}
    \caption{Overview of user functionality}
    \label{fig:AS:overview}
\end{figure}

In the following sections, we will describe how the file storage is organized,
and take a closer look at how the different functionality are solved.

\section{File Storage}
\label{sec:AS:FS}

The solution proposed in this thesis, is that only a simple key-value store is
needed on the server side. This may be extended with an \ac{ACL} layer to
support user access and other features.

Two types of files exist: immutable and mutable files. The mutable files are used
as directories, in the sense that they contain the information needed to access
other directories or files in the form of capabilities.
A capability is a short alphanumeric string containing all information needed
to find, get, read and write a file or folder. This includes an identifier and
cryptographic keys.

In principle, the only operations the key-value store need to support are
\textbf{POST}, \textbf{GET}.

\subsection{Directory Structure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureFileSystem.pdf}
    \caption{File System Structure}
    \label{fig:AS:filesystem}
\end{figure}

The file and directory structure can be seen as a directed graph, as illustrated
in Figure \ref{fig:AS:filesystem}, and users can link in folders and files as
wanted. This provides a flexible and space-conservative structure that is easily
extendible.

Each client\footnote{I.e. the different user terminals.} keeps a local copy of
the identity and write key to the users root folder in a password
protected keychain. In the event of loss of one of the clients, a user can change
encryption keys (and identifier) for the root folder, and hence effectively
block out the compromised clients.

\input{tables/folder_entries}

A directory contains two types of data. It contains meta data about it self and
in addition zero or more entries. Table \ref{tbl:folder:contents} exhibits the
structure of the folder entries. The \emph{Alias} field is the name of a
specific child. The \emph{storage index} is the look-up value of the
corresponding child.

The meta data are described in Table \ref{tbl:folder:meta}. The \emph{Storage
Index} is a unique value derived from a directory's read key and serves as an
identifier for the directory in question. The other elements are used for
security purposes, and are described further in Chapter \ref{chap:CS}.

\input{tables/folder_meta}

\section{ACL/Authentication Layer}
There should be some layer present on the application which enforces \ac{ACL}s and
authenticates users which should have access to the stored files. From a security
standpoint this is not necessarily required. An attacker would have to be able
to guess the storage index(key) and the corresponding encryption key for that
index to be able to get any information out of the system. But there are however
several reasons why we believe this layer should be implemented.

\subsection{Block access}
If for whatever reason a storage index and corresponding decryption key is
leaked to some third-party, but not to the cloud provider, the layer can
prevent an unauthenticated user from retrieving the file. The possibility of
also denying authenticated users from retrieving files is also a wanted feature
for instance in the event of a stolen/lost terminal where the credentials are
saved.

\subsection{File Deletion}
% TODO: Ref write to dir
The way we handle folders allows a distinction between write access and read
access. The write key can be used to deduce a secret that can be safely leaked
to the server which in turn would be used decide if a user has permission to
delete a folder. It could also be used for deciding if a user has permission to
write to files, but this can be verified by the server in terms of the
signature.
For immutable files there is no concept of write-access, only read. It is
both illogical and impractical to assume to read access should also yield
delete-access. A layer which identifies which users first creates a file can
by the same method decide who should be able to delete a file. This might also
be in the interest of accounting and billing.

\subsection{Accounting}
If this application were to by run by the cloud storage provider, it is
important to be able to decide which person should be billed for the storage of
files as well as the traffic generated by users uploading and downloading
files. For an immutable file the storage can be decided by who created the
file, the traffic is billed on whoever retrieved or uploaded a file.
Accounting might also be interesting for an organization using a third party
cloud provider. For instance an employee who leaves the organization might be
tempted to copy all the data stored on the server, the organization should then
be able to discover what he has done. It is however worth noting that if the
accounting happens server side there is no real way to verify that all logs
stored there are correct, since the cloud provider will have access to at least
delete them.

\section{User scenarios}

The various user scenarios the software has to support, provides a logic way to
describe the external properties of the system. The fundamental operations are
\emph{downloading}, \emph{uploading} and \emph{sharing} of files.

\subsection{Download file}

When a user wishes to download a file or directory, all that is needed is the
password to unlock the local keychain on the user terminal, as depicted in Figure
\ref{fig:AS:download}. The client sends a GET request with the identifier in
question, and the server responds with the encrypted folder. This contains the
capabilities needed to locate and decrypt the underlying files and folders.
After decrypting the contents, the client again queries the server with the
identifier of the wanted file, and there after decrypts it, before displaying it
to the user.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureDownload.pdf}
    \caption{Scenario: Downloading of files}
    \label{fig:AS:download}
\end{figure}

\subsection{Upload Files}

Figure \ref{fig:AS:upload} shows the process of uploading new files. The only
information the server in the cloud receives, are identifiers and encrypted
containers. The user is also given the opportunity to transfer the corresponding
identifiers and capabilities to other users.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureUpload.pdf}
    \caption{Scenario: Uploading of files}
    \label{fig:AS:upload}
\end{figure}

Before uploading, the client has to find, download and decrypt the directory the
files are to be placed in. This process was described in the previous section.
The cryptographic details of the Upload Operation can be found in Section
\ref{sec:CS:UF}.

\subsection{Share files}

As shown in Figure \ref{fig:AS:sharing}, for Alice to be able to share files
with Bob, she first has to create a new directory. After the capabilities to
this directory has been shared with Bob, this directory is going to be the
secure channel where they can share folders and files.

Before transferring the capabilities to Bob, Alice links the shared directory to
a parent directory, so she can easily find it again at a later time. She can
also link files to the shared directory.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureShare.pdf}
    \caption{Scenario: Sharing files}
    \label{fig:AS:sharing}
\end{figure}

The capability distribution is a key design issue, and has to be performed in a
secure manner. This can be solved in a variety of ways, and the solutions
proposed in this thesis will be described in Chapter TODO.

After receiving the capabilities for the shared folder from Alice, Bob requests
and receives the encrypted shared directory, in addition to linking it with a
parent directory for future usage. He can then download shared files as if they
where his own.

\paragraph{Read-Only shares.}

If Alice wants to share a directory in Read Only Mode with Bob, she can simply
not include the write capability in the parent directory. This will work as
intended until Alice wants to write to the folder, thus the write capability has to
be stored another place. We will implement this as a special folder under the
root folder, and link in all such folders and files the ``normal'' way here.
This process is illustrated in Figure \ref{fig:AS:readonly}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureShareReadOnlyFolder.pdf}
    \caption{Sharing write-protected folders}
    \label{fig:AS:readonly}
\end{figure}

%**************************************%
\chapter{Cryptographic Architecture}
%**************************************%
\label{chap:CS}
This chapter will elaborate on the cryptographic solutions applied to the
architectural scheme in Chapter \ref{chap:AS}. We will take a closer look at
how confidentiality, integrity and authentication can be integrated into the
proposed architecture.

%A fundamental scheme for key distribution is needed to realize the desired
%security features, hence an appropriate solution for key distribution will
%also be given.

The first section is a brief introduction explaining the basic
security concept used by the application. Following is a detailed description of
the cryptographic solutions adapted. The cryptographic solutions are revealed
in terms of file and directory operations performed by the application. The
chapter ends with a description of a users keychain.

\section{Security Concept}

The basic security concept of the application is to keep a user's remote storage
confidential to a third-party storage provider. To solve this, the application
encrypt files locally at the users terminal before uploading them to the
third-party storage provider. When accessing a file, the application first
download the encrypted file and further decrypt it locally. To enable this
simple encryption scheme, the user terminal is required to possess at least one
cryptographic key. Cryptographic keys are stored in a single keychain at the user
terminal.

By initially knowing that files are placed encrypted on a remote server and that
the local user possess one or more cryptographic keys, we can continue with a
more comprehensive description of the complete cryptographic solution. The
details are explained in terms of the following directory and file operations.

\section{Directory operations}
\label{sec:CS:DO}

This section presents the two basic directory operations used by the
application. The ``create directory'' and ``open directory'' operations are
explained as follows.

\subsection{Create Directory}

The create directory operation is divided into two subsequent parts. First, the
directory must be created locally at the user's terminal. Second, the directory
must further be uploaded to the remote server.  Uploading a file or directory is
possible only if the user is authenticated.

Creating and uploading a directory from the user terminal is illustrated in
Figure \ref{fig:CS:CD}.

\begin{figure}[h!]
    \centering
        \includegraphics[width=\columnwidth]{CryptoCreateFolder.pdf}
	    \caption{Creating and uploading a directory.}
    \label{fig:CS:CD}
\end{figure}

Before creating a new directory it is necessary to generate an RSA key-pair. The
key-pair is specific to the new directory and consists of a public and private
signing key. The signing key is further used to derive a write and a read key
for the corresponding directory. The read key is a hashed value of the write
key, while the write key equals the hashed value of the signing  key. 

% TODO: Will we use counter IV?
After key generation, the public key is directly added to the new directory. The
directory's storage index is further added as a hash value of the directory's
read key. The next value added to the directory is the initialization vector
\ac{IV}. The IV is generated from a counter value stored at the user terminal. It
is used to prevent predictable ciphertext, when the directory's entries are encrypted.

The next value added to the directory is the write enabler. The write enabler is
an HMAC-SHA-2 value created from the directory's write key and a static chosen
text value. It is uploaded as a part of the directory, but can never be
downloaded from the server. The write enabler is used by the server to enable
users, that possess the directory's write key, to modify the directory. This
ensures that only authorized users can modify a directory.

After adding the write enabler, the user must add the directory's private
signing key. The signing key should only be available for users with write
permission to the directory. It is therefore encrypted with the directory's
write key before it is added to the directory. The signing key is encrypted using \ac{AES} in
\ac{CBC} mode. The next value added is the directory's entries. The entries of a
directory should only be visible to users with read permissions to
the directory. They are therefore encrypted with the directory's \ac{IV} and read
key prior to insertion. The entries are encrypted using \ac{AES} in \ac{CBC} mode. The
last value added to the directory is a signed hash value of the encrypted
entries. The hash value is encrypted with the signing key using \ac{RSA}. A
signature is needed for other users to know that the directory was created from
an authorized user.

After creating a new directory, the directory is further uploaded to the remote
server.

It is important to notice that none of the values contained within the
directory or any of the cryptographic keys are kept locally by the user. The
user can only achieve the public and private keys through the remote directory.
The directory's read and write keys can only be achieved through capabilities stored
in the remote directory's parent directory. This is true for all directories
stored on the server except for the user's root directory. The keys to the
root directory are stored in the user's local keychain. The keyring is explained
in Section \ref{KEYRING}.

\subsection{Open Directory}

This section describes the procedure for opening a directory. Opening a
directory involves both downloading, verifying and decrypting the directory. The
download and verify procedure is illustrated in Figure \ref{fig:CS:VOD} and
described below. A description of the subsequent decryption procedure follows.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{VerifyOpenFolder.pdf}
    \caption{Downloading and verifying a remote directory.}
    \label{fig:CS:VOD}
\end{figure}

First of all, to download a desired directory, the user must be in
possession of a read key specific to that directory. The read key is either
created from a hash value of the directory's write key, or obtained from a read
capability stored in the parent directory.

The directory's storage index is further obtained. It is either created from the
obtained read key, or obtained from the read capability stored in the parent
directory. The storage index is a simple hash value of the read key. It is used to
localize the specific directory on the remote server. The localized directory is
further downloaded to the user's terminal.

When the correct directory is downloaded, it will further exhibit a verification
procedure prior to decryption. The verification procedure is illustrated in
Figure \ref{fig:CS:VOD}.

The purpose of the verification procedure is to check the integrity of the
content and to verify that it has been written by an authorized user.
If one or neither of these checks are verified, the directory content will not
be decrypted.

The first check verifies the correctness of the public key stored within the
downloaded directory. The key must be checked to ensure that it belongs to the signing
key. If it does, it indicates that an authorized user has signed the directory
content. The check is carried out by hashing the directory's public key and
comparing it with a verification capability.

If the directory passes the first check, it will further be checked for content
integrity. The integrity check ensures that the directory content, in form of
entries, has not been tampered with. It is carried out by decrypting a stored
encrypted hash value in the directory and comparing it against the hash value of
the directory's encrypted entries. The encrypted hash value stored in the
directory is decrypted using the previously verified public key. The integrity
check is depicted as a part of Figure \ref{fig:CS:VOD}.

If the directory passes the verification procedure, the user will decrypt the
directory's encrypted entries using the directory specific read key. The decryption procedure
is illustrated as a part of Figure \ref{fig:CS:OD}. An \ac{IV} is additionally
used with the read key to carry out the decryption procedure. The \ac{IV} is easily
fetched from the directory prior to decryption.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{OpenFolder.pdf}
    \caption{Decrypting a remote directory: Decrypting directory content and
    obtaining the signature key.}
    \label{fig:CS:OD}
\end{figure}

\subsection{Modify directory}
In addition to read the content of a directory, the user might want to write to it as well. 
To be able to modify a downloaded directory, the user must be in possession of
the directory's write key. The write key is needed to obtain the directory's
signing key and write enabler. 

The signing key is needed by the user to correctly sign the
modified directory. Remember that a directory can only be read by users if it
contains a valid signature. Obtaining the signing key from a downloaded
directory is shown as a part of Figure \ref{fig:CS:OD}.

The write enabler is generated as a HMAC-SHA-2 value from the write key and a
static known text value. It is used to prove the user's write permissions to the
receiving ACL layer at the remote server. This ensures that the directory has
been modified by an authorized user.

The user fetches the encrypted signing key and decrypts it with the
write key. This is illustrated in Figure \ref{fig:CS:OD}.


\section{File Operations}
This section describes the elementary file operations supported by the 
application. The ``create file'' and ``open file'' operations are considered.

\subsection{Create File}
In the create file operation, a file must be created locally on the user's terminal
prior to upload. The operation is depicted in Figure \ref{fig:CS:CF} and
described as follows.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{CryptoCreateFile.pdf}
    \caption{Creating and uploading a file. }
    \label{fig:CS:CF}
\end{figure}

The user chooses a local file to upload. This file is depicted as the
``content'' value in Figure \ref{fig:CS:CF}. A cryptographic write key, specific
for the new file, is further generated. The key generation algorithm is
explained in Section \ref{KEYGEN}. The write key is further hashed to create a
file specific storage index. The storage index is stored in the new file. A
file's storage index has the same property as a directory's storage index. The
\ac{IV} is the next value that is inserted into the new file. It is
generated from a counter stored at the user's terminal.

The previously chosen file content is further encrypted with the write key and
file \ac{IV}. The encrypted file content is then inserted to the new file. The last
value added to the new file is an encrypted hash value of the encrypted content.
The hash value is encrypted using the file's write key. Both the file content
and hash value are encrypted using \ac{AES} in \ac{CBC} mode.

\subsection{Open File} 
\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{CryptoOpenFile.pdf}
    \caption{Downloading a file from the server}
    \label{fig:CS:OF}
\end{figure}

The process of retrieving a file is illustrated in figure \ref{fig:CS:OF}.A
file is located by hashing the write key, which in turn is obtained either by
knowledge by the user or client or from a parent folder. The ciphertext, the
\ac{IV} and the encrypted hash of the ciphertext is downloaded from the server.
The ciphertext is hashed client side and the encrypted hash from the server is
decrypted with the write key, if these two outputs match the ciphertext has not
been tampered with. The ciphertext is then decrypted using the write key and
\ac{IV} to obtain the file contents.

\section{Keychain}

As stated, each client keeps a local copy of the identity and write key to the
personal root folder in a password protected keychain. This is done to be able
to encrypt the root folder with a key that is not based on a password, but
completely randomly generated. In addition, this means that no special scheme is
needed for the root folder, as we can use the same procedures as for ``normal''
folders as defined in the previous sections.

The strength of a password is related to its length and its randomness
properties. Passwords shorter than 10 characters are usually considered to be
weak \cite{pbkdf_nist}. In the event of loosing one of the clients, and thus the
keychain, a potential attacker can use fast password cracking attacks to try to
compromise the root folder keys. As an precaution for this, we will use
\ac{PBKDF2}/RFC2898\footnote{http://tools.ietf.org/html/rfc2898} with a salt
value to create additional computational work for the process of unlocking the
keychain. This method is known as key stretching \cite{keystretch}.



\section{Choice of cryptographic primitives}
The scheme which has been described in this section requires three primitives;
a cryptographic hash function, a symmetric cipher and an asymmetric cipher
which can be used for digital signatures. The choices should reflect the
following security demands of our application, all with the assumption that the
possible attacker has access to vast quantities of computing power.

% TODO: Sikkerhetskrav bør vi definere tidligere
\begin{enumerate}
    \item It should be infeasible to break confidentiality for any file or folder
    \item It should be infeasible to break integrity for any file or folder
\end{enumerate}

\subsection{Symmetric Cipher}
For a symmetric cipher the choice is pretty simple; \ac{AES}. \ac{AES} is
a standard, has been around for a long time, and does not have any serious
security issues as long as it is used correctly.
% Kilder kilder TODO

%**************************************%
\chapter{Implementation}
%**************************************%
This chapter describes the implementation of our proof-of-concept client and
server.

\section{Server}

The server, in the most basic form, has to support two operations -- sending
and receiving files. In addition, an \ac{ACL} layer is needed to support user
management and access control to able to allow the deletion of files.

\subsection{Communication and Architecture}
% (\texttt{POST}) (\texttt{GET})

By definition, cloud applications are accessible over the Internet. The system
we are creating, should be able to send and receive files and information from a
server in the cloud. The \ac{HTTP} networking protocol is the foundation of data
communication for the World Wide Web, and is thus chosen as the method of
transferring information between client and server.

The Web is built around an architectural style called \ac{REST} 
\cite[ch. 5]{fielding}, and is defined by four interface constraints:
identification of resources, manipulation of resources through representations,
self-descriptive messages, and, hypermedia as the engine of application state. 
In addition, \ac{REST} dictates five\footnote{And one optional, Code on demand,
which is not applicable for our system.} architectural constraints
\cite{fielding}:

\begin{itemize}\addtolength{\itemsep}{-0.5\baselineskip}
  \item Client-server
  \item Stateless
  \item Cacheable
  \item Layered system
  \item Uniform interface
\end{itemize}

In our case, resources are the encrypted files, and the architectural
constraints of \ac{REST} also matches that of our system as a
whole, thus, the server application are designed in a \acs{REST}ful manner.

% TODO: HTTPS

\subsection{Environment}

The Python programming language in a Linux environment was chosen as development
platform, together with a set of applications, interfaces and micro frameworks.
The rationale for each of these follows.

\paragraph{Python} Python is a high-level general-purpose programming language.
It was chosen to work with due to previous knowledge and experience by the
authors, in addition to its simplicity.

\paragraph{Apache} The Apache HTTP Server is a well tested and used web
server. According to \citet{netcraft}, Apache is by far the most used web server
software, and has been so since 1996. It was chosen on the basis of previous
experience and its superb documentation.

\paragraph{\acs{WSGI}} The Python \ac{WSGI} is, as the name suggests, an
interface between a web server and a Python application. It is defined in
\ac{PEP} 3333\footnote{\url{http://www.python.org/dev/peps/pep-3333/}}, and
specifies both sides of the interface -- the \emph{application} and the
\emph{server}. The server side is implemented in the form of an Apache 
module, namely \texttt{mod\_wsgi}, and the application is where we put our
code.

For each of the requests the server (i.e. \texttt{mod\_wsgi}) receives, a call
to the application function is made with two arguments -- a data structure
containing the environment variables, and a callback function for which the
application uses to return data to the requesting user via the server.

\paragraph{Pyroutes} To adhere to the \ac{DRY} principles, we chose to make use
of a micro framework around \ac{WSGI} called Pyroutes. It provides shortcuts for
the most frequently used functionality when developing web services, as that of
\ac{URL} handling and processing of submitted user data in the form
of \texttt{GET} and \texttt{POST} requests.

\begin{figure}[h!]
    \centering
\begin{verbatim}
|-- cloudstorage
|   |-- __init__.py
|   |-- db.py
|   |-- fileserver.py
|   |-- filesystem.py
|   |-- settings.py
|   `-- sql
|       `-- write_enablers.sql
|-- handler.py
|-- pyroutes_settings.py
`-- tests
    `-- filesystem_tests.py
\end{verbatim}
    \caption{Server module structure}
    \label{fig:I:server}
\end{figure}

\subsection{Communication with Client}
% HTTP/SSL/RESTfull

\subsection{Upload/Download Functionality}

\subsection{ACL functionality}


\section{Client}
% Java/Android/Dalvik/JCE/Commons HTTPClient
% Security vs. Usability - Rationale for GUI
% MVC? V=Android GUI
%

\subsection{Structure}
% Package Structure, some nice UML (?)
% Which qualities do we wish to achive? Security, Performance, Usability

\subsection{Communication with Server}
% Do not repeat what is said in Server equivalent section
% Apache commons, Serialization of objects

\subsection{Cryptography}
% Do not repeat previous chapter, but specific of implementation
% JCE, Code organization, Capabilities
% Classes, which functionality we get from them

To get access to cryptographic functions in Java we need to call on what is
known as the \ac{JCE}. Basically the \ac{JCE} was earlier an extension which
was not part of the official Java \ac{JDK}, but has since been embedded in what
is called the \ac{JCA}\cite{jca}.
Basically the \ac{JCA} provides factories for accessing implementations of
cryptographic functions from different Providers. In essence what this mean is
that there may be more than one implementation of for instance \ac{AES}. It is
possible to specify which provider to use, but it is also possible to make the
\ac{JRE} choose whatever provider it sees most fit. 

\subsubsection{Encryption} 

The {\bf javax.crypto.cipher} class in the \ac{JCA} deal with encryption and
decryption of both asymmetric and symmetric ciphers.  It also handles the mode
of operation and padding scheme to be used. Which scheme is used for all three
choices depend on the String sent to the factory in the Class. A Basic example
of how we use encryption can be seen in Listing \ref{lst:cipherexample}. It is
also possible to specify the \ac{IV} through the {\bf init} call, if not the
\ac{IV} is automatically generated.

\lstinputlisting[label=lst:cipherexample, caption=\ac{AES}
encryption in Java]
{listings/cipher_example.java}

\subsubsection{Key Generation}
Key Generation is accomplished in a similar way as Encryption, but through {\bf
javax.crypto.KeyGenerator} and {\bf javax.crypto.KeyPairGenerator} for
symmetric and asymmetric keys respectively. Listing \ref{lst:keygenexample}
shows how we generate these keys.

\lstinputlisting[label=lst:keygenexample, caption= \ac{AES} and
\ac{RSA} key generation in Java]
{listings/keygen_example.java}

\subsubsection{Digital Signatures}
Digital Signatures can be accomplished with the help of a \ac{RSA}-keypair. The
factory used for creation of signatures as well as validation of signatures
lives in {\bf java.security.Signature}. How we use these can be seen in Listing 
\ref{lst:signatureexample}.

\lstinputlisting[label=lst:signatureexample, caption= Digital signatures in
Java using \ac{RSA}]
{listings/keygen_example.java}

\subsubsection{Hashing} For cryptographic hashing the \ac{JCA} is similar to
other cryptographic operations, and the factory lives in {\bf
java.security.MessageDigest}. However, we need double \ac{SHA}-256, which is
not an option. The implementation we use for double \ac{SHA}-256 is shown in
Listing 

\lstinputlisting[label=lst:hashingexample, caption= Double \ac{SHA}-256 in Java]
{listings/hashing_example.java}

\subsection{Sharing}
% Sequence Diagram - How we use the cryptographic solutions (and which ones) to
% achieve sharing, securely

\subsection{Adding a new client}
% Same as sharing rationale.

\subsection{User Interface}
% goal: As easy as possible!

% First start: Generate new cap/import an old one (Adding a new client section)
% Browsing remote file(s)/folders
% Sharing a file - first/following times - Key Distribution
% Uploading/Downloading file

\subsection{Secure storage of files on Client}
% Can we view files without them leaving traces on filesystem?
% Optional/Possible?

%**************************************%
\chapter{Results}
%**************************************%

%**************************************%
\chapter{Discussion}
%**************************************%
\section{Complexity}
% Hvordan vi lagrer filer
% Lagring av nøkler
% Hvordan direktorier fungerer
% Hvordan vi deler

\subsection{Keys}

\subsection{Files}

\subsection{Folders}

\subsection{Sharing}

\section{Security}
% Hvordan angripe?
% ACL lag bare ekstra sikkerhet, man kan ikke cracke noe uten keyen!
This thesis is written with the basis that we are hiring storage from an
untrusted provider, and the security of the application should primarily
reflect that. With this starting point we can assume that all data stored on
the server is obtainable by the provider.

\subsection{Passive attacks}
% Avhengig av cryptographic primitives
% Confidentiality den største utfordringen
% Her trengs det gode kilder
The provider will have access to all data on the server, and also know what
data stored is part of files and what is part of folders. The confidentiality
of both files and folders relies primarily on the symmetric cipher used to
encrypt the data. But for folders one can obtain this key if one manages to
obtain the asymmetric private key belonging to the folder. In other words a
folder is attackable both trough the asymmetric and the symmetric cipher used.
If the confidentiality of a folder is breached this will also lead to the
attacker being able to decrypt and subfolders or filer, in contrast the breach
of confidentiality of a file will only compromise that specific file. It is
also important to note that users will use a root folder which any other file
or folder relies on, if the confidentiality of this folder is breached, all
files are effectively compromised.

\subsubsection{Brute Force attacks}

\subsubsection{RSA attacks}

\subsubsection{AES attacks}

\subsection{Active attacks}
% MITM - Dersom vi f.eks. skrur av SSL-laget
% Innside attacker - hos Amazon


\subsection{Terminal security}
% What happens if someone steals a terminal
% OR install some backdoor/torjan etc?
Given enough users, at some point there will be a users who looses his
terminal, for instance a mobile phone, a terminal might also be broken into
without the users knowledge.

\section{Performance}
% 1 mappe med 100 filer i, tar ikke mye lenger tid å åpne enn en mappe med 3
% filer i

\section{Omitted features}
% Ting vi ikke har lagt inn
% - Cascading deletes? Loops.
% - Hvem 'eier' en directory
% - Garbage collection? (vanskelig)

%**************************************%
\chapter{Conclusion and Future Work}
%**************************************%

% BibTeX bibliography lives in external file
\bibliographystyle{plainnat}
\bibliography{references}
% TODO: Can we fix references in order of apperance?

\appendix
\appendixpage
\addappheadtotoc
% Appendix goes here


\end{document}
