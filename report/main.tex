\documentclass[pdftex,english,10pt,b5paper,twoside]{book}
%TODO: Correct format, not a4
\usepackage[T1]{fontenc} % In case we want special characters
\usepackage[utf8]{inputenc} % We are all writing in UTF-8

\usepackage[numbers]{natbib} % We need to tweak our referencing a bit.
\usepackage{appendix} % Fixes formatting of appendices
\usepackage[printonlyused]{acronym} % Package to handle the acronym list
\usepackage{graphicx} % We *may* use images
\graphicspath{{images/}} % and it is clean to put them in a separate dir
\usepackage{hyperref} % Internal and external links is nice
\hypersetup{pdfborder=0 0 0} % ..especially without red borders
\usepackage{amstext} % To support \text in math mode

% Packages and settings for code listings
\usepackage{listings}
\usepackage{caption}
\usepackage{upquote}
\usepackage{xcolor}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\lstset{
language=Java,
keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
identifierstyle=\ttfamily,
commentstyle=\color[rgb]{0.133,0.545,0.133},
stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
showstringspaces=false,
basicstyle=\small,
numberstyle=\footnotesize,
numbers=left,
stepnumber=1,
numbersep=10pt,
tabsize=2,
breaklines=true,
prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
breakatwhitespace=false,
aboveskip={1.5\baselineskip},
columns=fixed,
upquote=true,
extendedchars=true,
frame=bottomline,
inputencoding=utf8
}

% Set equal margins on book style
% \usepackage{layout} % Use \layout to print out the margins (debug)
%\usepackage{geometry}
%\geometry{bindingoffset=1cm}
\usepackage[lmargin=25mm,rmargin=25mm,tmargin=27mm,bmargin=30mm]{geometry}

% Restyle chapter headers
\usepackage{fix-cm}
\makeatletter
\renewcommand{\@makechapterhead}[1]{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \vspace{15pt}%
    \ifnum \c@secnumdepth >\m@ne
        %\hfill\huge\scshape \@chapapp\space
        \hfill\fontsize{60}{90}\selectfont \thechapter % Chapter number
        \par\nobreak
        \vskip 20\p@
    \fi
    \interlinepenalty\@M
    \hfill \Huge \scshape #1\par % Chapter title
    \vspace{5pt}
    \hrule
    \nobreak
    \vskip 40\p@
  }}
\makeatother

\author{Eirik Haver \and Eivind Melvold \and Pål Ruud}
\title{Master thesis - Cloud Storage Vault}
\date{\today}

\begin{document}

\include{title}
\pagestyle{empty}

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
\pagestyle{plain}
\pagenumbering{Roman}
\setcounter{page}{1}

%  Writers should follow a checklist consisting of:
% Motivation: Why do we care about the problem and results?
% Problem Statement: What problem are we trying to solve? Scope/limits.
% Approach: How did we go about solving or making progress on the problem?
% Results: What is the answer? Numbers, not vague 'very', 'small' etc.
% Conclusions: What are the implications of your answer? Further work.
%
%  Each section is typically a single sentence, although there is room for
%  creativity.

\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

The work behind this project report was carried out during the spring semester
in 2011 at the Norwegian University of Science and Technology (NTNU), Department
of Telematics (ITEM).
\vspace{13pt}

\begin{center}
Eirik Haver, Eivind Melvold and Pål Ruud
\vspace{13pt}

\end{center}

\tableofcontents

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\listfigurename}
\listoffigures

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\listtablename}
\listoftables

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{\lstlistlistingname}
\lstlistoflistings
\cleardoublepage

\chapter*{Acronyms}
\addcontentsline{toc}{chapter}{Acronyms}

\begin{acronym}
\acro{ACL}{Access Control List}
\acro{AES}{Advanced Encryption Standard}
\acro{CA}{Certification authority}
\acro{DSA}{Digital Signature Algorithm}
\acro{DSS}{Digital Signature Scheme}
\acro{FAQ}{Frequently Asked Questions}
\acro{IaaS}{Infrastructure as a Service}
\acro{LAFS}{Least Authority File System}
\acro{MITM}{Man-in-the-middle}
\acro{NIST}{National Institute of Standards and Technology}
\acro{PBKDF2}{Password-Based Key Derivation Function version 2}
\acro{PaaS}{Platform as a Service}
\acro{PGP}{Pretty Good Privacy}
\acro{PKI}{Public Key Infrastructure}
\acro{RSA}{Rivest, Shamir and Adleman}
\acro{SaaS}{Software as a Service}
\acro{SHA}{Secure Hash Algorithm}
\acro{SSL}{Secure Socket Layer}
\acro{TLS}{Transport Layer Security}
\acro{VM}{Virtual Machine}
\end{acronym}

%**************************************%
\chapter{Introduction}
%**************************************%
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Method}

\section{Outline}

The work is presented as per the following chapters:

\paragraph{Chapter 2} provides background knowledge of the technologies and
software used.


%**************************************%
\chapter{Background}
%**************************************%
% Cloud (computing)
\section{Security Services}
This section briefly explains certain security services used in this
thesis. A security service is any processing or communication service that
enhances the security of the data processing systems and the information
transfers of any organization\cite[p. 12]{stallings}.

\paragraph{Confidentiality} is the art of keeping a message secret from
unauthorized parties\cite[p. 18]{stallings}. This can typically be done by
either preventing other parties access to the message at all, or making the
contents unreadable for instance by the use of encryption. 

\paragraph{Integrity} in a security perspective deals with detecting,
preventing or recovering a message from being changes by an unauthorized party
\cite{stallings}.

\paragraph{Authentication} is the act for a user, service or similar to prove
that he is what he claims to be\cite{stallings}. 

\subsection{Nonrepudiation} prevents either sender or receiver of a message
from denying a transmitted message, in other words one party can prove the
other parties involvement\cite{stallings}.

\section{Cryptographic Primitives}
This section explains the low level security primitives used in this thesis.

\subsection{Encryption}
Encryption is the process of transforming some information into an unreadable
form. Encryption is primarily used to enforce Confidentially, but can also be
used for other purposes such as authentication. In a very basic form an
encryption scheme consist of an algorithm, the cipher, a key and a message, the
plaintext, that is all used to create an encrypted message, a ciphertext. If
a good cipher is used, knowledge of the cipher, plaintext and ciphertext should
not be enough to obtain the key.

\paragraph{Block-cipher and Stream-cipher} are classifications on how a cipher
treats data\cite[p. 32]{stallings}. With a block-cipher data will be encrypted
in blocks of specific sizes. If the data length is not a multiple of the block
size, the data will be padded. A stream cipher on the other hand will encrypt
the message co.

\paragraph{Symmetric encryption} is an encryption scheme where the same key is
used for both encryption and decryption\cite[p. 32]{stallings}. \ac{AES} is a
block cipher and is the current standard for symmetric encryption. \ac{AES}
works on a block of 128-bit and support keys of 128, 192 and 256-bit. 

\paragraph{The mode of operation} used for a symmetric encryption scheme
enables subsequent safe use of the same key.
%TODO: Vi kan ikke nevne alle her, vi nevner de som er nødvendige. CBC?

\paragraph{Asymmetric encryption} is an encryption scheme where a different key
is used for encryption than decryption\cite[p. 259]{stallings}. An asymmetric
encryption scheme is often called a public-key encryption scheme, where one key
is defined as private and the other as public. The public key is shared to
allow other parties to encrypt messages for the owner of the private key. The
downside of asymmetric encryption compared to symmetric is that it requires a
larger key and has a larger computational overhead to obtain the same level of
confidentiality. The probably best known asymmetric cipher is \ac{RSA}.

\subsection{Cryptographic hash functions}
A cryptographic hash function is a deterministic mathematical procedure which
takes an arbitrary block of data and outputs a fixed-size bit string. The output
is referred to as the hash value, message digest or simply digest.
Another property of a cryptographic hash function is that the smallest change in
the input data (e.g. one bit) should completely change the output of the hash
function. In other words it should be infeasible to find the reverse of a
cryptographic hash function \cite[p. 335]{stallings}. It should also be infeasible to
find two blocks of data which produce the same hash value (a \emph{collision}).

The standard for cryptographic hash functions today are \ac{SHA}-1 and the
\ac{SHA}-2 family.

\section{Applications of cryptographic primitives}

\subsection{Digital Signatures}
A digital signature is the digital equivalent of a normal signature, it
verifies that an entity approves with or has written a message, the date the
signature was made and it should be verifiable by a third party \cite[p.
379]{stallings}. It should logically not be possible or at least unfeasible to
fake a digital signature. It is possible to create digital signatures with
\ac{RSA} there is also a standard for digital signatures called \ac{DSS} which
uses \ac{DSA} as the actual algorithm.

\subsection{Digital Certificates and PKI} A digital certificate is the pairing
of a digital signature and a public key\cite{stallings}.  By this scheme the
services confidentiality, authentication and nonrepudiation can be achieved.
Basically a person or other entity has a certificate with some clues about the
identity in it, e.g. the e-mail, together with a public key. This certificate
can then be signed using digital signatures to verify that some other entity
trusts this certificate. In practise the entity which signs certificates is the
\ac{CA} which all clients have the public key information for, and trusts. The
\ac{CA} will also contain information about which certificates has been
revoked, i.e. should not be trusted in use. Such a scheme is usually referred
to as a \ac{PKI}.

\subsubsection{PGP} \ac{PGP} is a scheme similar to \ac{PKI} but with no
\ac{CA} that all users trusts\cite{stallings}. Instead trust is made between
users by somehow verifying their public key, for instance by meeting face to
face. A user can then sign another users key, set a trust level for the user
and publish this information to a keyserver. Another user can then calculate a
trust to an unknown person based on the trust set by peoples that he trusts. 

\subsection{SSL/TLS}
\ac{TLS} and its predecessor \ac{SSL} are techniques for obtaining
confidentiality, integrity for transfer of files over a
network\cite{stallings}. It does so by a combination of different algorithms
and primitives, but a digital certificate is required for authentication. 

\subsection{PBKDF2}
%TODO: See if we actually use this.
\ac{PBKDF2} is a key derivation function to create an encryption key based on
a password. The point of this is that a password is often something that should
be memorable to a person, but what is memorable to a person might be a to short
phrase to withstand a brute force attack. What \ac{PBKDF2} does is make the
process of deriving the key from the password an expensive process in terms of
computational power, to make it more resistant to brute force attacks.

\section{Security Attacks}
This section briefly list security attacks relevant to this thesis, as defined
by \citeauthor{stallings}.
%TODO: Mulig man skal bruke en annen måte å refere kilden på her

\paragraph{Active and passive attacks} are classifications of security attacks,
where a passive attack attempts to learn or make use of information from the
system but does not affect system resources. An active attack attempts to alter
system resources or affect their operation.

\paragraph{Traffic analysis} is the art of capturing communication sent between
two parties. This information might contain secrets or might for instance leak
enough information about an encryption key to make it breakable. 

\paragraph{Masquerade} is an active attack where the attacker pretends to be
one of the legit parties.

\paragraph{Replay} is an active attack where the attacker capture some data in
a communication session and subsequently retransmit that information.

\paragraph{Modification of messages} is an active attack where the attacker
alters some of the contents of a message sent between two communicating
parties.

\paragraph{Denial of Service} is an active attack where the attacker seeks to
make resources unavailable for legit users, i.e. by overloading an application
by sending it lots of traffic.

\paragraph{\acl{MITM}} is an attack where an attacker intercepts messages
between the communicating parties and then either relay or substitute the
intercepted message.

\subsection{Attacks on cryptographic primitives}
Even though cryptographic primitives are designed to be secure, they might have
both flaws and be used in an incorrect fashion. 

\paragraph{Cryptanalysis attack} is an attempt to deduce a specific plaintext
or to deduce the key being used in a ciphertext.

\paragraph{Brute-force attack} is an attack where you try to obtain a secret by
testing the algorithm with up to all possible inputs. The secret might be an
encryption key or the data fed into a cryptographic hash function.

\section{Cloud Computing} 
In a draft\cite{cloud_nistdef} \ac{NIST} defines cloud computing as:
\begin{quote} 
Cloud computing is a model for enabling ubiquitous, convenient,
on-demand network access to a shared pool of configurable computing resources
(e.g., networks, servers, storage, applications, and services) that can be
rapidly provisioned and released with minimal management effort or service
provider interaction.  
\end{quote}

\subsection{Service Models}
\ac{NIST} also defines three service models which deals with what kind of
service the consumer is able to rent from a provider.

\paragraph{\ac{SaaS}} is the capability for a consumer to run the provider's
application running on cloud infrastructure, using a thin-client, browser or
similar. Gmail\footnote{\url{http://www.gmail.com}} can be seen as an example
of this.

\paragraph{\ac{PaaS}} is the capability for a consumer to deploy software onto
the cloud, but without actually controlling the underlying platform, operating
system etc.

\paragraph{\ac{IaaS}} is the capability provided to the consumer to provision
processing, storage, networks and other fundamental computing resources where
he can run arbitrary software, including operating systems and applications. An
example is hiring a \ac{VM}.

\subsection{Deployment Models}
The \ac{NIST} draft also lists several Deployment Models which deals with how
the cloud is organized in terms of where it is hosted and who has access to it.

\paragraph{Private Cloud} is a cloud infrastructure operated solely for an
organization. Which party manages the cloud and where it is located is not
given.

\paragraph{Community Cloud} is a cloud infrastructure is shared by several
organizations to serve a common concern. Where it is located and who manages it
is not given.

\paragraph{Public Cloud} is a cloud infrastructure where basically everyone or
at least a large group can have access, and is owned by a external provider of
cloud services.

\paragraph{Hybrid Cloud} is a cloud infrastructure composed of two or more
clouds of any other model. 

\subsection{Security considerations} 
There are some considerations when using cloud services from an external provider 
as opposed to self controlled hardware, software and plattforms. Most notably
is that you loose the control of selecting the people which will have physical
and digital access to the infrastructure. In essence this means that the
provider can read every data sent to and from the cloud as well as the data
saved in the cloud.

Another risk is that information might be leaked to other users of the same
cloud. For instance it might be able possible for a \ac{VM} to leak information
to other \ac{VM}s on the same host. 
%TODO: kilde

\section{Existing Solutions}
There are a number of existing storage solutions for storing data in the cloud,
with more or less of the functionality required to fulfill the problem
description for this thesis. The section highlights some of them.

\subsection{Dropbox} Dropbox\footnote{\url{http://www.dropbox.com}} is a
commercial application for storing data in the cloud, more specific using
Amazons S3 storage service. It claims that files are stored encrypted with
\ac{AES}-256 which can only be decrypted with the users username and password,
and that Dropbox employees are not able to access the files of the
user\footnote{\url{http://www.dropbox.com/help/27}}. However Dropbox also has a
Forgot password feature which means that Dropbox can read the users files if
they really want to. Their \ac{FAQ} does however say that some people have been
successfull in putting truecrypt containers in Dropbox which effectivly makes
dropbox secure\footnote{\url{http://www.dropbox.com/help/179}}.

\subsection{Tahoe-LAFS}
Tahoe-\ac{LAFS}\footnote{http://www.tahoe-lafs.org} is an open source
cloud storage file system which does fulfill the requirements set by our
problem description in regards to security. In Tahoe-\ac{LAFS} files are
exclusivly encrypted client-side, before beeing uploaded into the cloud.
Tahoe-\ac{LAFS} also uses erasure-coding to obtain redundancy across multiple
storage servers.  

%TODO: kilde, enten paperet vi brukte i prosjektet, muligens
% http://tahoe-lafs.org/source/tahoe-lafs/trunk/docs/about.html

%**************************************%
\chapter{Architectural Solution}
%**************************************%
\label{chap:AS}

The architectural solution of a secure cloud file sharing system has to convince
its users that the functions indeed are secure, and that the concepts are easy
to understand and accept.

\section{Introduction}
% FIXME: Can we just drop this section and include its contents in the chapter
% intro?

The architecture has to support various user functionality. Figure
\ref{fig:AS:overview} exhibits Alice uploading files to the cloud, and
thereafter transferring the necessary information to Bob so that he also can
gain access to the files.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureOverview.pdf}
    \caption{Overview of user functionality}
    \label{fig:AS:overview}
\end{figure}

In the following sections, we will describe how the file storage is organized,
and take a closer look at how the different functionality are solved.

\section{File Storage}
\label{sec:AS:FS}

The solution proposed in this thesis, is that only a simple key-value store is
needed on the server side. This may be extended with an \ac{ACL} layer to
support user access and other features.

Two types of files exist: immutable and mutable files. The mutable files are used
as directories, in the sense that they contain the information needed to access
other directories or files in the form of capabilities.
A capability is a short alphanumeric string containing all information needed
to find, get, read and write a file or folder. This includes an identifier and
cryptographic keys.

In principle, the only operations the key-value store need to support are
\textbf{PUT}, \textbf{GET} and \textbf{UPDATE}. The latter one is required to
make changes to the ``directory'' files.

\subsection{Directory Structure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureFileSystem.pdf}
    \caption{File System Structure}
    \label{fig:AS:filesystem}
\end{figure}

The file and directory structure can be seen as a directed graph, as illustrated
in Figure \ref{fig:AS:filesystem}, and users can link in folders and files as
wanted. This provides a flexible and space-conservative structure that is easily
extendible.

Each client\footnote{I.e. the different user terminals.} keeps a local copy of
the identity and write capability to the users root folder in a password
protected keyring. In the event of loss of one of the clients, a user can change
encryption keys (and identifier) for the root folder.

%%The structure of a directory must be written here!
%
%A directory contains two types of data. It contains meta data about it
%self and data in form of entries.
%
%The meta data describing the directory can be listed as follows:
%\begin{itemize}
%\item Public Key
%\item Storage Index
%\item Initialization Vector (IV)
%\item Write Enabler
%\item Encrypted Signing Key
%\item Signature
%\end{itemize}
%The \emph{public key} is a public RSA-key that corresponds to the directory's
%own private signature key. The \emph{storage index} is a unique hash value
%from a directory's read key and serves as an identifier for the specific
%directory. An \emph{IV} is used when encrypting the directory content to prevent
%predictable ciphertext. The \emph{write enabler} is an HMAC-SHA-2 value created
%from the directory's write key and a static chosen text value. It is used by the
%ACL layer on the server side to check that the user has write permission to
%upload the directory. The upload procedure on the server side is shown in \#\#,
%and is explained later in this section. The \emph{encrypted signing key} is
%stored inside the directory to enable users with write permissions to download
%and change the directory content with a valid signature. The last value in the
%directory's meta data is the signature. The \emph{signature} is an encrypted
%hash value of the meta data describing the directory's children. The hash value
%is encrypted with the directory's private signing key. 
%
%In addition to its own meta data, a directory contains zero or more entries. An
%entry is a structure containing meta data about a directory's child. 
%With a directory's child we mean either a file or a subdirectory that is linked
%from the directory.
%
%The structure of an entry is shown in Table \ref{tbl:folder:contents}.
%
%\input{tables/folder_metadata}
%
%The \emph{Alias} field is the name of a specific child. The \emph{storage
%index} is the look-up value of the corresponding child. The three remaining
%fields are reserved for capabilities. As mentioned in Section \ref{sec:AS:}, a
%capability encapsulates all the information needed by a user to either find, get, read or
%write a specific child. The content of the write, read and verify capability is
%elaborated in Section \ref{sec:CS:KAC}.

\section{ACL/Authentication Layer}
There should be some layer present on the application which enforces \ac{ACL}s and
authenticates users which should have access to the stored files. From a security 
standpoint this is not necessarily required. An attacker would have to be able
to guess the storage index(key) and the corresponding encryption key for that
index to be able to get any information out of the system. But there are however
several reasons why we believe this layer should be implemented.

\subsection{Block access}
If for whatever reason a storage index and corresponding decryption key is
leaked to some third-party, but not to the cloud provider, the layer can
prevent an unauthenticated user from retrieving the file. The possibility of
also denying authenticated users from retrieving files is also a wanted feature
for instance in the event of a stolen/lost terminal where the credentials are
saved.

\subsection{File Deletion}
% TODO: Ref write to dir
The way we handle folders allows a distinction between write access and read
access. The write key can be used to deduce a secret that can be safely leaked
to the server which in turn would be used decide if a user has permission to
delete a folder. It could also be used for deciding if a user has permission to
write to files, but this can be verified by the server in terms of the
signature.
For immutable files there is no concept of write-access, only read. It is
both illogical and impractical to assume to read access should also yield
delete-access. A layer which identifies which users first creates a file can
by the same method decide who should be able to delete a file. This might also
be in the interest of accounting and billing.

\subsection{Accounting}
If this application were to by run by the cloud storage provider, it is
important to be able to decide which person should be billed for the storage of
files as well as the traffic generated by users uploading and downloading
files. For an immutable file the storage can be decided by who created the
file, the traffic is billed on whoever retrieved or uploaded a file.
Accounting might also be interesting for an organization using a third party
cloud provider. For instance an employee who leaves the organization might be
tempted to copy all the data stored on the server, the organization should then
be able to discover what he has done. It is however worth noting that if the
accounting happens server side there is no real way to verify that all logs
stored there are correct, since the cloud provider will have access to at least
delete them.

\section{User scenarios}

The various user scenarios the software has to support, provides a logic way to
describe the external properties of the system. The fundamental operations are
\emph{downloading}, \emph{uploading} and \emph{sharing} of files.

\subsection{Download file}

When a user wishes to download a file or directory, all that is needed is the
password to unlock the local keyring on the user terminal, as depicted in Figure
\ref{fig:AS:download}. The client sends a GET request with the identifier in
question, and the server responds with the encrypted folder. This contains the
capabilities needed to locate and decrypt the underlying files and folders.
After decrypting the contents, the client again queries the server with the
identifier of the wanted file, and there after decrypts it, before displaying it
to the user.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureDownload.pdf}
    \caption{Scenario: Downloading of files}
    \label{fig:AS:download}
\end{figure}

\subsection{Upload Files}

Figure \ref{fig:AS:upload} shows the process of uploading new files. The only
information the server in the cloud receives, are identifiers and encrypted
containers. The user is also given the opportunity to transfer the corresponding
identifiers and capabilities to other users.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureUpload.pdf}
    \caption{Scenario: Uploading of files}
    \label{fig:AS:upload}
\end{figure}

Before uploading, the client has to find, download and decrypt the directory the
files are to be placed in. This process was described in the previous section.
The cryptographic details of the Upload Operation can be found in Section
\ref{sec:CS:UF}.

\subsection{Share files}

As shown in Figure \ref{fig:AS:sharing}, for Alice to be able to share files
with Bob, she first has to create a new directory. After the capabilities to
this directory has been shared with Bob, this directory is going to be the
secure channel where they can share folders and files.

Before transferring the capabilities to Bob, Alice links the shared directory to
a parent directory, so she can easily find it again at a later time. She can
also link files to the shared directory.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureShare.pdf}
    \caption{Scenario: Sharing files}
    \label{fig:AS:sharing}
\end{figure}

The capability distribution is a key design issue, and has to be performed in a
secure manner. This can be solved in a variety of ways, and the solutions
proposed in this thesis will be described in Chapter TODO.

After receiving the capabilities for the shared folder from Alice, Bob requests
and receives the encrypted shared directory, in addition to linking it with a
parent directory for future usage. He can then download shared files as if they
where his own.

\paragraph{Read-Only shares.}

If Alice wants to share a directory in Read Only Mode with Bob, she can simply
not include the write capability in the parent directory. This will work as
intended until Alice wants to write to the folder, thus the write capability has to
be stored another place. We will implement this as a special folder under the
root folder, and link in all such folders and files the ``normal'' way here.
This process is illustrated in Figure \ref{fig:AS:readonly}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{ArchitectureShareReadOnlyFolder.pdf}
    \caption{Sharing write-protected folders}
    \label{fig:AS:readonly}
\end{figure}

%**************************************%
\chapter{Cryptographic Architecture}
%**************************************%
\label{chap:CS}
This chapter will elaborate on the cryptographic solutions applied to the
architectural scheme in Chapter \ref{chap:AS}. We will take a closer look at
how confidentiality, integrity and authentication can be integrated into the
proposed architecture.

%A fundamental scheme for key distribution is needed to realize the desired
%security features, hence an appropriate solution for key distribution will
%also be given.

The first section is a brief introduction explaining the basic
security concept used by the application. Following is a detailed description of
the cryptographic solutions adapted. The cryptographic solutions are revealed
in terms of file and directory operations performed by the application. The
chapter ends with a description of a users keyring.

\section{Security Concept}
The basic security concept of the application is to keep a users remote storage
confidential to a third-party storage provider. To solve this, the application
encrypt files locally at the users terminal before uploading them to the
third-party storage provider. To further access files, the application
decrypt files locally after download. To enable this simple
encryption scheme, the user terminal is required to possess at least one
cryptographic key. Cryptographic keys are stored in a single keyring at the user
terminal.

By initially knowing that files are encrypted on a remote server and that the local user
possess one or more cryptographic keys, we can continue with a more comprehensive
description of the complete cryptographic solution. The details of the complete
solution are explained in terms of the following directory and file operations.

\section{Directory operations}
\label{sec:CS:DO}
This section presents the two basic directory operations used by the
application. The ``create directory'' and ``open directory'' operations are explained as
follows.

\subsection{Create Directory}
The create directory operation is divided into two subsequent parts. First,
the directory must be created locally at the user's terminal. Second, the directory must
further be uploaded to the remote server. Uploading a file or directory is
possible only if the user is authenticated.

Creating and uploading a directory from the user terminal is illustrated in
Figure \ref{fig:CS:CD}.

\begin{figure}[h!]
    \centering
        \includegraphics[width=\columnwidth]{CryptoCreateFolder.pdf}
	    \caption{Creating and uploading a directory.}
    \label{fig:CS:CD}
\end{figure}

Before creating a new directory it is necessary to generate an RSA key-pair. The
key-pair is specific to the new directory and consists of a public and private
signing key. The signing key is further used to derive a write and a read key
for the corresponding directory. The read key is a hashed value of the write
key, while the write key equals the hashed value of the signing  key. 
%How keys are generated and derived is explained in Section \ref{sec:CS:KAC}.

After key generation, the public key is directly added to the new directory. The
directory's storage index is further added as a hash value of the directory's
read key. The next value added to the directory is the initialization vector
\ac{IV}. The IV is generated from a counter value stored at the user terminal. It
is used to prevent predictable ciphertext, when the directory entries are encrypted. 
The next value added to the directory is the write enabler. The write enabler is
an HMAC-SHA-2 value created from the directory's write key and a static chosen
text value. It is used by the \ac{ACL} layer on the server side to check that a
user has write permission to upload the directory.

After adding the write enabler, the user must add the directory's private
signing key. The signing key should only be available for users with write
permission to the directory. It is therefore encrypted with the directory's
write key before it is added to the directory. The signing key is encrypted using \ac{AES} in
\ac{CBC} mode.The next value added is the directory's entries. The entries of a
directory should only be visible to users with read permissions to
the directory. They are therefore encrypted with the directory's \ac{IV} and read
key prior to insertion. The entries are encrypted using \ac{AES} in \ac{CBC} mode. The
last value added to the directory is a signed hash value of the encrypted
entries. The hash value is encrypted with the signing key using \ac{RSA}.

After creating a new directory, the directory is further uploaded to the remote
server. 

It is important to notice that none of the values contained within the
directory or any of the cryptographic keys are kept locally by the user. The
user can only achieve the public and private keys through the remote directory.
The directory's read and write keys can only be achieved through capabilities stored
in the remote directory's parent directory. This is true for all directories
stored on the server except for the user's root directory. The keys to the
root directory are stored in the user's local keyring. The keyring is explained
in Section \ref{KEYRING}.

\subsection{Open Directory}

This section describes the procedure for opening a directory. Opening a
directory involves both downloading, verifying and decrypting the directory. The
download and verify procedure is illustrated in Figure \ref{fig:CS:VOD} and
described below. A description of the subsequent decryption procedure follows.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{VerifyOpenFolder.pdf}
    \caption{Downloading and verifying a remote directory.}
    \label{fig:CS:VOD}
\end{figure}

First of all, to download a desired directory, the user must be in
possession of a read key specific to that directory. The read key is either
created from a hash value of the directory's write key, or obtained from a read
capability stored in the parent directory.

The directory's storage index is further obtained. It is either created from the
obtained read key, or obtained from the read capability stored in the parent
directory. The storage index is a simple hash value of the read key. It is used to
localize the specific directory on the remote server. The localized directory is
further downloaded to the user's terminal.

When the correct directory is downloaded, it will further exhibit a verification
procedure prior to decryption. The verification procedure is illustrated in
Figure \ref{fig:CS:VOD}.

The purpose of the verification procedure is to check the integrity of the
content and to verify that it has been written by an authorized user. 
If one or neither of these checks are verified, the directory content will not
be decrypted.

The first check verifies the correctness of the public key stored within the 
downloaded directory. The key must be checked to ensure that it belongs to the signing
key. If it does, it indicates that an authorized user has signed the directory
content. The check is carried out by hashing the directory's public key and
comparing it with a verification capability.

If the directory passes the first check, it will further be checked for content
integrity. The integrity check ensures that the directory content, in form of
entries, has not been tampered with. It is carried out by decrypting a stored
encrypted hash value in the directory and comparing it against the hash value of
the directory's encrypted entries. The encrypted hash value stored in the
directory is decrypted using the previously verified public key. The integrity
check is depicted as a part of Figure \ref{fig:CS:VOD}.

If the directory passes the verification procedure, the user will decrypt the
directory's encrypted entries using the directory specific read key. The decryption procedure
is illustrated as a part of Figure \ref{fig:CS:OD}. An \ac{IV} is additionally
used with the read key to carry out the decryption procedure. The \ac{IV} is easily
fetched from the directory prior to decryption.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\columnwidth]{OpenFolder.pdf}
    \caption{Decrypting a remote directory: Decrypting directory content and
    obtaining the signature key.}
    \label{fig:CS:OD}
\end{figure}

To modify a downloaded directory after the decryption procedure, the user has to
obtain the directory's signing key. Recall that a directory must contain a valid signature to prove that it has been
modified by a user with write permissions. The signature consists of an encrypted hash value of the
directory's encrypted entries. The hash value is encrypted with the signing key.

The user fetches the encrypted signing key and decrypts it with the
write key. This is illustrated in Figure \ref{fig:CS:OD}.


\section{File Operations}

\subsection{Open File}

\subsection{Create File}

The process of uploading a file onto a remote server was illustrated in Figure
\ref{fig:AS:upload}. This section will provide a more detailed description of the
process and specify the functionality of the Upload operation at the user
terminal.

When uploading a file to the remote file structure, described in Section \ref{sec:AS:FS}, two
operations are needed. First of all, it is important to add the desired file's
meta data into the remote parent directory. This meta data will serve as a link
to the uploaded file. The second operation is to upload the desired file.

These two operations can be broken into the following five steps:

%**************************************%
\chapter{Implementation}
%**************************************%

%**************************************%
\chapter{Results}
%**************************************%

%**************************************%
\chapter{Discussion}
%**************************************%
\section{Complexity}
% Hvordan vi lagrer filer
% Lagring av nøkler
% Hvordan direktorier fungerer
% Hvordan vi deler

\subsection{Keys}

\subsection{Files}

\subsection{Folders}

\subsection{Sharing}

\section{Security}
% Hvordan angripe?
% ACL lag bare ekstra sikkerhet, man kan ikke cracke noe uten keyen!
This thesis is written with the basis that we are hiring storage from an
untrusted provider, and the security of the application should primarily
reflect that. With this starting point we can assume that all data stored on
the server is obtainable by the provider. 

\subsection{Passive attacks}
% Avhengig av cryptographic primitives
% Confidentiality den største utfordringen
% Her trengs det gode kilder
The provider will have access to all data on the server, and also know what
data stored is part of files and what is part of folders. The confidentiality
of both files and folders relies primarily on the symmetric cipher used to
encrypt the data. But for folders one can obtain this key if one manages to
obtain the asymmetric private key belonging to the folder. In other words a
folder is attackable both trough the asymmetric and the symmetric cipher used.
If the confidentiality of a folder is breached this will also lead to the
attacker being able to decrypt and subfolders or filer, in contrast the breach
of confidentiality of a file will only compromise that specific file. It is
also important to note that users will use a root folder which any other file
or folder relies on, if the confidentiality of this folder is breached, all
files are effectively compromised.

\subsubsection{Brute Force attacks}

\subsubsection{RSA attacks}

\subsubsection{AES attacks}

\subsection{Active attacks}
% MITM - Dersom vi f.eks. skrur av SSL-laget
% Innside attacker - hos Amazon


\subsection{Terminal security}
% What happens if someone steals a terminal
% OR install some backdoor/torjan etc?
Given enough users, at some point there will be a users who looses his
terminal, for instance a mobile phone, a terminal might also be broken into
without the users knowledge. 

\section{Performance}
% 1 mappe med 100 filer i, tar ikke mye lenger tid å åpne enn en mappe med 3
% filer i

\section{Omitted features}
% Ting vi ikke har lagt inn
% - Cascading deletes? Loops.
% - Hvem 'eier' en directory
% - Garbage collection? (vanskelig)

%**************************************%
\chapter{Conclusion and Future Work}
%**************************************%

% BibTeX bibliography lives in external file
\bibliographystyle{plainnat}
\bibliography{references}
% TODO: Can we fix references in order of apperance?

\appendix
\appendixpage
\addappheadtotoc
% Appendix goes here


\end{document}
